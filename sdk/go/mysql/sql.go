// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mysql

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/unobravo/pulumi-mysql/sdk/go/mysql/internal"
)

type Sql struct {
	pulumi.CustomResourceState

	CreateSql pulumi.StringOutput `pulumi:"createSql"`
	DeleteSql pulumi.StringOutput `pulumi:"deleteSql"`
	Name      pulumi.StringOutput `pulumi:"name"`
}

// NewSql registers a new resource with the given unique name, arguments, and options.
func NewSql(ctx *pulumi.Context,
	name string, args *SqlArgs, opts ...pulumi.ResourceOption) (*Sql, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CreateSql == nil {
		return nil, errors.New("invalid value for required argument 'CreateSql'")
	}
	if args.DeleteSql == nil {
		return nil, errors.New("invalid value for required argument 'DeleteSql'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Sql
	err := ctx.RegisterResource("mysql:index/sql:Sql", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSql gets an existing Sql resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSql(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SqlState, opts ...pulumi.ResourceOption) (*Sql, error) {
	var resource Sql
	err := ctx.ReadResource("mysql:index/sql:Sql", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Sql resources.
type sqlState struct {
	CreateSql *string `pulumi:"createSql"`
	DeleteSql *string `pulumi:"deleteSql"`
	Name      *string `pulumi:"name"`
}

type SqlState struct {
	CreateSql pulumi.StringPtrInput
	DeleteSql pulumi.StringPtrInput
	Name      pulumi.StringPtrInput
}

func (SqlState) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlState)(nil)).Elem()
}

type sqlArgs struct {
	CreateSql string  `pulumi:"createSql"`
	DeleteSql string  `pulumi:"deleteSql"`
	Name      *string `pulumi:"name"`
}

// The set of arguments for constructing a Sql resource.
type SqlArgs struct {
	CreateSql pulumi.StringInput
	DeleteSql pulumi.StringInput
	Name      pulumi.StringPtrInput
}

func (SqlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlArgs)(nil)).Elem()
}

type SqlInput interface {
	pulumi.Input

	ToSqlOutput() SqlOutput
	ToSqlOutputWithContext(ctx context.Context) SqlOutput
}

func (*Sql) ElementType() reflect.Type {
	return reflect.TypeOf((**Sql)(nil)).Elem()
}

func (i *Sql) ToSqlOutput() SqlOutput {
	return i.ToSqlOutputWithContext(context.Background())
}

func (i *Sql) ToSqlOutputWithContext(ctx context.Context) SqlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlOutput)
}

// SqlArrayInput is an input type that accepts SqlArray and SqlArrayOutput values.
// You can construct a concrete instance of `SqlArrayInput` via:
//
//	SqlArray{ SqlArgs{...} }
type SqlArrayInput interface {
	pulumi.Input

	ToSqlArrayOutput() SqlArrayOutput
	ToSqlArrayOutputWithContext(context.Context) SqlArrayOutput
}

type SqlArray []SqlInput

func (SqlArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sql)(nil)).Elem()
}

func (i SqlArray) ToSqlArrayOutput() SqlArrayOutput {
	return i.ToSqlArrayOutputWithContext(context.Background())
}

func (i SqlArray) ToSqlArrayOutputWithContext(ctx context.Context) SqlArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlArrayOutput)
}

// SqlMapInput is an input type that accepts SqlMap and SqlMapOutput values.
// You can construct a concrete instance of `SqlMapInput` via:
//
//	SqlMap{ "key": SqlArgs{...} }
type SqlMapInput interface {
	pulumi.Input

	ToSqlMapOutput() SqlMapOutput
	ToSqlMapOutputWithContext(context.Context) SqlMapOutput
}

type SqlMap map[string]SqlInput

func (SqlMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sql)(nil)).Elem()
}

func (i SqlMap) ToSqlMapOutput() SqlMapOutput {
	return i.ToSqlMapOutputWithContext(context.Background())
}

func (i SqlMap) ToSqlMapOutputWithContext(ctx context.Context) SqlMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlMapOutput)
}

type SqlOutput struct{ *pulumi.OutputState }

func (SqlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sql)(nil)).Elem()
}

func (o SqlOutput) ToSqlOutput() SqlOutput {
	return o
}

func (o SqlOutput) ToSqlOutputWithContext(ctx context.Context) SqlOutput {
	return o
}

func (o SqlOutput) CreateSql() pulumi.StringOutput {
	return o.ApplyT(func(v *Sql) pulumi.StringOutput { return v.CreateSql }).(pulumi.StringOutput)
}

func (o SqlOutput) DeleteSql() pulumi.StringOutput {
	return o.ApplyT(func(v *Sql) pulumi.StringOutput { return v.DeleteSql }).(pulumi.StringOutput)
}

func (o SqlOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Sql) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type SqlArrayOutput struct{ *pulumi.OutputState }

func (SqlArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sql)(nil)).Elem()
}

func (o SqlArrayOutput) ToSqlArrayOutput() SqlArrayOutput {
	return o
}

func (o SqlArrayOutput) ToSqlArrayOutputWithContext(ctx context.Context) SqlArrayOutput {
	return o
}

func (o SqlArrayOutput) Index(i pulumi.IntInput) SqlOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Sql {
		return vs[0].([]*Sql)[vs[1].(int)]
	}).(SqlOutput)
}

type SqlMapOutput struct{ *pulumi.OutputState }

func (SqlMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sql)(nil)).Elem()
}

func (o SqlMapOutput) ToSqlMapOutput() SqlMapOutput {
	return o
}

func (o SqlMapOutput) ToSqlMapOutputWithContext(ctx context.Context) SqlMapOutput {
	return o
}

func (o SqlMapOutput) MapIndex(k pulumi.StringInput) SqlOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Sql {
		return vs[0].(map[string]*Sql)[vs[1].(string)]
	}).(SqlOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SqlInput)(nil)).Elem(), &Sql{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlArrayInput)(nil)).Elem(), SqlArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlMapInput)(nil)).Elem(), SqlMap{})
	pulumi.RegisterOutputType(SqlOutput{})
	pulumi.RegisterOutputType(SqlArrayOutput{})
	pulumi.RegisterOutputType(SqlMapOutput{})
}
